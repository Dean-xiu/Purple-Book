//。给定答案序列和用户猜的序列，统计有多少数字位置正确 （A）
//有多少数字在两个序列都出现过但位置不对（B）。
//每组输入第一行为序列长度n，第二行是答案序列，接下来是若干猜测序列。
//猜测序列全0时该组数据结束。n=0时输入结束。
//样例输入：
//4
//1 3 5 5
//1 1 2 3 
//4 3 3 5 
//6 5 5 1 
//6 1 3 5 
//1 3 5 5 
//0 0 0 0 
//10
//1 2 2 2 4 5 6 6 6 9 
//1 2 3 4 5 6 7 8 9 1 
//1 1 2 2 3 3 4 4 5 5 
//1 2 1 3 1 5 1 6 1 9 
//1 2 2 5 5 5 6 6 6 7 
//0 0 0 0 0 0 0 0 0 0 
//0
//样例输出：
//Game 1: 
//(1, 1) 
//(2, 0) 
//(1, 2) 
//(1, 2) 
//(4, 0) 
//Game 2 :
//(2, 4)
//(3, 2) 
//(5, 0) 
//(7, 0)
#include<stdio.h>
#define maxn 1010

//int main()
//{
//	// n存储每组的个数 a存储答案序列 b存储测试序列
//	int n, a[maxn], b[maxn];
//	int kase = 0;
//	while (scanf_s("%d", &n) == 1 && n)
//	{
//		printf("Game %d:\n", ++kase);
//		for (int i = 0; i < n; i++)
//			scanf_s("%d", &a[i]);
//		for (;;)
//		{
//			int A = 0, B = 0;
//			// 第一个循环 计算测试和答案序列位置相同的数字
//			for (int i = 0; i < n; i++)
//			{
//				scanf_s("%d", &b[i]);
//				if (a[i] == b[i])
//					A++;
//			}
//			//如果是测试序列的第一个是0 则退出
//			if (b[0] == 0)
//				break;
//			//第二个循环 计算0-9数字在测试序列和答案序列各出现多少次
//			for (int d = 1; d <= 9; d++)
//			{
//				int c1 = 0, c2 = 0;
//				for (int i = 0; i < n; i++)
//				{
//					if (a[i] == d)
//						c1++;
//					if (b[i] == d)
//						c2++;
//				}
//				if (c1 < c2)
//					B += c1;
//				else
//					B += c2;
//			}
//			//B-A 筛去位置相同的个数
//			printf("        (%d,%d)\n", A, B - A);
//		}
//	}
//	return 0;
//}